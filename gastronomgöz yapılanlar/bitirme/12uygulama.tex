\section{ÖNERİLEN SİSTEM VE İMPLEMENTASYON}

Bu bölümde, GastronomGöz sisteminin önerilen mimarisi ve implementasyonu detaylı olarak açıklanmaktadır. Sistemin geliştirilmesi sürecinde backend API mimarisi, veritabanı tasarımının uygulanması, derin öğrenme modellerinin entegrasyonu, mobil uygulama geliştirme süreci ve deployment işlemleri ayrı alt başlıklar halinde sunulmaktadır.

\subsection{Backend API Mimarisi ve İmplementasyonu}

\subsubsection{Proje Dizin Yapısı ve Modüler Mimari}

Backend projesi, kaygıların ayrılması prensibi doğrultusunda modüler bir yapıda organize edilmiştir \cite{martin2009clean}. Toplam 33 Python dosyası ve 4 ana modülden oluşan bu yapı, kodun okunabilirliğini, bakımını ve test edilebilirliğini artırmaktadır. Proje ana uygulama dosyası (app.py), ortam bazlı yapılandırma dosyası (config.py) ve bağımlılıkları içeren models, schemas, api, core, middleware ve utils klasörlerinden oluşmaktadır. Models klasörü kullanıcı ve tahmin geçmişi ORM modellerini, schemas klasörü kimlik doğrulama ve kullanıcı profili validasyon şemalarını, api klasörü kimlik doğrulama (5 endpoint), kullanıcı profili (3 endpoint), yapay zeka tahmini (2 endpoint) ve geçmiş analitik uç noktalarını içermektedir. Core klasöründe model yöneticisi (tekil nesne örüntüsü), görüntü işleme hattı ve porsiyon tahmin algoritması bulunmaktadır. Middleware klasörü genel hata yönetimini, utils klasörü özel doğrulayıcıları, static klasörü ise kullanıcı yüklenen görüntüleri barındırmaktadır.

Bu dizin organizasyonu, Model-View-Controller mimarisinin bir varyasyonu olarak değerlendirilebilir. Models klasörü veri katmanını, api klasörü controller katmanını, schemas klasörü ise validasyon katmanını temsil etmektedir.

\subsubsection{Flask Application Factory Pattern}

Flask uygulaması, fabrika örüntüsü kullanılarak başlatılmıştır \cite{grinberg2018flask}. Bu yaklaşım, farklı ortamlar (geliştirme, test, üretim) için ayrı yapılandırmalarla uygulama örneklerinin oluşturulmasına olanak tanımaktadır. Ana uygulama dosyasında SQLAlchemy veritabanı ve JWTManager kimlik doğrulama bileşenleri başlatılmakta, CORS desteği eklenmekte ve kimlik doğrulama, kullanıcı profili ve tahmin API blueprint'leri kaydedilmektedir. Factory pattern kullanımı farklı ortamlar için ayrı örnekler oluşturulmasına, birim testlerde test odaklı yapılandırmalar kullanılmasına, döngüsel import problemlerinin önlenmesine ve eklentilerin geç başlatma ile yüklenmesine olanak sağlamaktadır.

\pagebreak{}

\subsubsection{Veritabanı Modellerinin İmplementasyonu}

SQLAlchemy ORM kullanılarak tanımlanan veritabanı modelleri, Python sınıfları olarak gerçekleştirilmiştir \cite{sqlalchemy2023}. Bu yaklaşım, SQL injection saldırılarını önlemekte ve veritabanı işlemlerini nesne yönelimli bir şekilde gerçekleştirmeyi sağlamaktadır.

User modeli users tablosunu temsil etmekte ve kullanıcı kimlik bilgilerini saklamaktadır. Model birincil anahtar olarak id, benzersiz ve indekslenmiş email alanı, password\_hash alanı, isim, aktiflik durumu ve oluşturulma zamanı alanlarını içermektedir. UserProfile ile bire-bir ilişki ve PredictionHistory ile bire-çok ilişki tanımlanmıştır. Şifre hashleme işlemi pbkdf2:sha256 algoritması ile gerçekleştirilmektedir. Bu algoritma, NIST tarafından önerilen güvenli bir şifreleme yöntemidir \cite{grassi2017bcrypt}.

UserProfile modeli, kullanıcıların fiziksel özelliklerini ve sağlık metriklerini saklamaktadır. Model boy (cm), kilo (kg), yaş, cinsiyet, aktivite seviyesi, hedef tipi ve günlük kalori hedefi alanlarını içermektedir. Model üzerinde VKİ (Vücut Kitle İndeksi) hesaplama, BMR (Bazal Metabolizma Hızı) hesaplama ve TDEE (Toplam Günlük Enerji Harcaması) hesaplama fonksiyonları tanımlanmıştır. BMR hesaplaması Harris-Benedict formülü kullanılarak yapılmaktadır. Erkekler için formül 88.362 + (13.397 × kilo) + (4.799 × boy) - (5.677 × yaş), kadınlar için ise 447.593 + (9.247 × kilo) + (3.098 × boy) - (4.330 × yaş) şeklindedir. TDEE hesaplamasında aktivite seviyesine göre çarpanlar kullanılmaktadır: hareketsiz (1.2), hafif aktif (1.375), orta aktif (1.55), çok aktif (1.725) ve aşırı aktif (1.9).

\pagebreak{}

\subsubsection{RESTful API Endpoint Tasarımı}

Sistem, REST (Representational State Transfer) mimari prensiplerine uygun olarak tasarlanmıştır \cite{fielding2002rest}. Temel API endpoint'leri geliştirilmiş olup, ek özellikler için endpoint'ler planlanmaktadır. Tüm endpoint'ler standart HTTP metodlarını kullanmakta ve JSON formatında veri alışverişi yapmaktadır.

\begin{table}[h]
\centering
\caption{Backend API Endpoint Listesi (Geliştirilen ve Planlanan)}
\label{tab:api_endpoints}
\small
\begin{tabular}{|l|l|l|p{4cm}|c|}
\hline
\textbf{Endpoint} & \textbf{Method} & \textbf{Auth} & \textbf{Açıklama} & \textbf{Durum} \\ \hline
\multicolumn{5}{|c|}{\textbf{Authentication API}} \\ \hline
/auth/register & POST & - & Yeni kullanıcı kaydı & \checkmark \\ \hline
/auth/login & POST & - & JWT token üretimi & \checkmark \\ \hline
/auth/refresh & POST & Refresh & Access token yenileme & \checkmark \\ \hline
/auth/me & GET & JWT & Kullanıcı bilgileri & \checkmark \\ \hline
/auth/logout & POST & JWT & Token invalidation & \checkmark \\ \hline
\multicolumn{5}{|c|}{\textbf{User Profile API}} \\ \hline
/api/user/profile & GET & JWT & Profil getirme & \checkmark \\ \hline
/api/user/profile & PUT & JWT & Profil güncelleme & \checkmark \\ \hline
/api/user/goals & PUT & JWT & Kalori hedefi ayarlama & \checkmark \\ \hline
\multicolumn{5}{|c|}{\textbf{Prediction API}} \\ \hline
/api/predict & POST & JWT & Yemek tahmini & \checkmark \\ \hline
/api/food-classes & GET & - & Yemek listesi (101 sınıf) & \checkmark \\ \hline
\multicolumn{5}{|c|}{\textbf{History \& Analytics API (Planlı)}} \\ \hline
/api/history & GET & JWT & Tahmin geçmişi listesi & Planlı \\ \hline
/api/history/<id> & GET & JWT & Tahmin detayı & Planlı \\ \hline
/api/history/<id> & DELETE & JWT & Tahmin silme & Planlı \\ \hline
/api/daily-log & GET & JWT & Günlük özet & Planlı \\ \hline
/api/stats & GET & JWT & İstatistikler & Planlı \\ \hline
\end{tabular}
\end{table}

\textbf{Mevcut Durum:} Temel kimlik doğrulama, kullanıcı profili ve tahmin uç noktaları aktif olarak çalışmaktadır (10 endpoint). Geçmiş ve analitik özellikleri veritabanı modellerinde tanımlı olup, API endpoint gerçekleştirmesi gelecek geliştirme fazlarında tamamlanacaktır.

Kullanıcı kimlik doğrulaması, JSON Web Token standardı kullanılarak gerçekleştirilmiştir \cite{jones2020jwt}. Sistem iki tür token kullanmaktadır: kısa ömürlü access token (15 dakika, API isteklerinde kullanılır) ve uzun ömürlü refresh token (30 gün, access token yenilemede kullanılır).

\pagebreak{}

\subsection{Yapay Zeka Modellerinin Entegrasyonu}

\subsubsection{Model Yönetim Sistemi - Singleton Pattern}

Derin öğrenme modellerinin yönetimi için tekil nesne tasarım örüntüsü kullanılarak ModelManager sınıfı geliştirilmiştir. Bu yaklaşım, uygulama boyunca tek bir model yöneticisi örneğinin oluşturulmasını garantileyerek bellek verimliliği sağlamaktadır. ModelManager sınıfı sınıf düzeyinde instance ve initialized bayrakları tutmakta, ilk oluşturulduğunda PyTorch device'ı (CUDA varsa GPU, yoksa CPU) belirlemekte ve dört model için (food\_model, u2net\_model, midas\_model, calories\_df) başlangıçta None değerleri atamaktadır. Tekil nesne örüntüsünün sağladığı avantajlar modellerin bellekte tek bir kopyasının tutulması, güvenli model erişimi, tutarlı model versiyonu kullanımı ve bellek tüketiminin minimize edilmesidir.

Modeller geç yükleme mekanizması ile ilk talep anında yüklenmektedir. Bu yaklaşım, uygulama başlangıç süresini önemli ölçüde azaltmaktadır. Yemek sınıflandırma modeli yükleme fonksiyonu önce modelin önbellekte olup olmadığını kontrol etmekte, varsa doğrudan döndürmekte, yoksa weights klasöründen model\_trained\_101class.hdf5 dosyasını yükleyerek önbelleğe almaktadır.

\subsubsection{Yemek Sınıflandırma Modeli - ResNet50}

Food-101 veri seti üzerinde ince ayar yapılmış ResNet50 modeli kullanılmıştır \cite{bossard2014food101}. Model, ImageNet ağırlıklarıyla ön eğitilmiş olup, aktarım öğrenimi yaklaşımı ile yemek tanıma görevine uyarlanmıştır \cite{pan2010transfer}. ResNet50 mimarisi 25.6 milyon parametre içermekte \cite{he2016resnet}, 224×224×3 boyutunda RGB görüntü girdisi almakta ve softmax aktivasyonu ile 101 yemek sınıfı çıktısı üretmektedir. Model Keras/TensorFlow çatısı ile geliştirilmiş \cite{abadi2016tensorflow}, Adam optimizer ve 0.0001 öğrenme oranı kullanılarak eğitilmiştir.

Görüntü ön işleme hattında görüntü 224×224 piksel boyutuna yeniden ölçeklenmekte, dizi formatına dönüştürülmekte, batch boyutu için genişletilmekte ve 0-1 aralığına normalize edilmektedir.

\pagebreak{}

\subsubsection{Segmentasyon Modeli - U2-Net}

Yemek görüntülerinden arka plan ayrıştırması için U2-Net segmentasyon modeli kullanılmıştır \cite{qin2020u2net}. Model, iç içe U-yapısı mimarisi sayesinde çok ölçekli öznitelik çıkarımı gerçekleştirmektedir. U2NET-P hafif versiyonu 4.7 milyon parametre ile mobil platformlar için optimize edilmiştir. Model 320×320×3 boyutunda giriş almakta ve 320×320 boyutunda ikili maske (0-255 değer aralığı) çıktısı üretmektedir. Model PyTorch çatısı ile geliştirilmiş \cite{paszke2019pytorch} ve kesişim bölümü birleşim metriki ile değerlendirilmektedir.

Segmentasyon hattı beş adımdan oluşmaktadır. İlk olarak görüntü RGB formatında yüklenmekte ve 320×320 boyutuna yeniden ölçeklenmektedir. Görüntü tensor formatına dönüştürülmekte ve ImageNet istatistikleri ile normalize edilmektedir (ortalama: 0.485, 0.456, 0.406; standart sapma: 0.229, 0.224, 0.225). İkinci adımda model çıkarımı gradyan hesaplaması olmadan gerçekleştirilmekte ve yedi çıktı seviyesinden ilki (d1) kullanılmaktadır. Üçüncü adımda tahmin normalize edilmekte ve 0-255 aralığına ölçeklenmektedir. Dördüncü adımda maske orijinal görüntü boyutuna yeniden ölçeklenmekte, beşinci adımda ise 127 eşik değeri ile ikili maskeye dönüştürülmektedir. Segmentasyon maskesi yemeğin piksel düzeyinde konturunu belirlemekte ve porsiyon ağırlığı tahmininde kullanılmaktadır.

\subsubsection{Porsiyon Ağırlığı Tahmin Algoritması}

Yemek ağırlığı tahmini için porsiyon bazlı bir algoritma geliştirilmiştir. Algoritma, segmentasyon maskesi alanı ve yemek sınıfına özgü porsiyon veritabanını kullanmaktadır. Porsiyon veritabanında 12 farklı yemek türü için küçük, orta ve büyük olmak üzere 3 porsiyon boyutu tanımlanmıştır. Örneğin pizza için küçük 150g, orta 250g, büyük 400g; hamburger için küçük 120g, orta 180g, büyük 250g; baklava için küçük 80g, orta 140g, büyük 200g olarak belirlenmiştir. Veritabanında bulunmayan yemekler için varsayılan değerler (küçük 80g, orta 130g, büyük 200g) kullanılmaktadır.

\pagebreak{}

Ağırlık hesaplama algoritması üç aşamalı olarak çalışmaktadır. İlk aşamada maske alanı, genişlik ve yükseklik değerleri kullanılarak porsiyon boyutu tahmin edilmektedir. İkinci aşamada yemek sınıfı porsiyon veritabanında aranmakta, bulunursa ilgili porsiyon için standart ağırlık, bulunamazsa varsayılan ağırlık alınmaktadır. Üçüncü aşamada alan bazlı ince ayar yapılmaktadır: maske alanı toplam görüntü alanına (640×480 piksel) bölünerek normalize edilmekte ve alan faktörü hesaplanmaktadır. Alan faktörü 0.8 ile 1.2 arasında sınırlandırılarak baz ağırlık üzerinde maksimum ±20% ayarlama yapılmaktadır. Algoritmanın çalışma prensibi şu adımları içermektedir: maske alanı hesaplanması (beyaz piksel sayısı), alanın toplam görüntü alanına göre normalize edilmesi, porsiyon boyutu belirlenmesi (0.15'ten küçükse küçük, 0.15-0.35 arası ise orta, 0.35'ten büyükse büyük), veritabanından baz ağırlık alınması ve alan faktörü ile ince ayar yapılması.

\subsubsection{Kalori Hesaplama ve Besin Değerleri}

Her yemek sınıfı için 100 gram başına kalori değerleri CSV formatında saklanmaktadır. Kalori hesaplaması şu formül ile yapılmaktadır:

\begin{equation}
\text{Toplam Kalori} = \frac{\text{Tahmini Ağırlık (g)}}{100} \times \text{Kalori}_{100g}
\end{equation}

Kalori hesaplama fonksiyonu kalori veri çerçevesinde yemek sınıfını aramakta, bulunamazsa hata vermektedir. Yemek bulunursa 100 gram başına kalori değeri alınmakta ve tahmini ağırlık ile çarpılarak toplam kalori hesaplanmaktadır. Sonuç virgülden sonra bir basamak olacak şekilde yuvarlanmaktadır.

\subsubsection{Derinlik Tahmini - MiDaS (Gelecek Geliştirme)}

MiDaS algoritması, tek kamera görüntüsünden derinlik tahmini için entegre edilmiştir \cite{ranftl2020midas}. Model gelecekte hacim bazlı ağırlık tahmini için kullanılacaktır. DPT\_Large transformer tabanlı mimarisi göreceli derinlik haritası çıktısı üretmektedir. Model PyTorch Hub üzerinden yüklenmekte olup şu an pasif durumdadır ve gelecek versiyonlarda aktifleştirilecektir.

\pagebreak{}

\subsection{Önerilen Mobil Uygulama Mimarisi}

\subsubsection{Flutter Framework ve Dart}

Mobil uygulama, Google tarafından geliştirilen Flutter framework'ü (versiyon 3.16+) ve Dart programlama dili kullanılarak tasarlanmıştır \cite{wu2018flutter}. Flutter, tek kod tabanı (single codebase) ile hem iOS hem de Android platformlarında native performans sunan cross-platform bir framework'tür \cite{biorn2018dartlang}.

\textbf{Not:} Bu bölümde sunulan mobil uygulama mimarisi, sistemin tam entegrasyonu için tasarlanmış ve dokümante edilmiştir. Mimari tasarım tamamlanmış olup, gerçekleştirme aşaması devam etmektedir.

Flutter seçiminin başlıca avantajları tek kod tabanı ile çoklu platform desteği (iOS, Android, Web), native performansa yakın hız (60 FPS), hot reload özelliği ile hızlı geliştirme döngüsü, zengin widget kütüphanesi ve Material Design 3.0 desteği \cite{google2023material} ile güçlü durum yönetimi çözümleridir (Provider, Riverpod, BLoC).

\subsubsection{Uygulama Mimarisi}

Mobil uygulama katmanlı mimari prensibi ile organize edilmiştir. Ana dizin yapısı main.dart uygulama başlangıç dosyası, screens klasörü ekran bileşenlerini (kimlik doğrulama, ana sayfa, kamera, tahmin sonuçları, geçmiş, istatistikler, profil ekranları), widgets klasörü yeniden kullanılabilir bileşenleri (özel buton, metin alanı, yüklenme göstergesi), models klasörü veri modellerini (kullanıcı, tahmin, günlük log), providers klasörü durum yönetimi sağlayıcılarını (kimlik doğrulama, kullanıcı, tahmin, geçmiş), services klasörü API servislerini (genel API, kimlik doğrulama, tahmin, depolama) ve utils klasörü yardımcı fonksiyonları (sabitler, doğrulayıcılar, yardımcılar) içermektedir. Config klasöründe tema ve renk şeması tanımlanmaktadır. Bu yapı kaygıların ayrılması prensibi ile her katmanın kendi sorumluluğuna odaklanmasını sağlamaktadır.

\pagebreak{}

\subsubsection{Ana Ekranlar ve Kullanıcı Akışı}

GastronomGöz mobil uygulaması, toplam 10 ana ekrandan oluşmaktadır:

\textbf{1. Authentication Ekranları:}
\begin{itemize}
    \item \textbf{Login Screen:} Email ve şifre ile giriş
    \item \textbf{Register Screen:} Yeni kullanıcı kaydı
\end{itemize}

\textbf{2. Ana Navigasyon Ekranları (Bottom Navigation Bar):}
\begin{itemize}
    \item \textbf{Home Screen:} Günlük özet, progress bar, son tahminler
    \item \textbf{Camera Screen:} Fotoğraf çekme ve galeri seçimi
    \item \textbf{History Screen:} Geçmiş tahminler listesi
    \item \textbf{Statistics Screen:} Grafikler ve analitik
    \item \textbf{Profile Screen:} Kullanıcı profili ve ayarlar
\end{itemize}

\textbf{3. Detay Ekranları:}
\begin{itemize}
    \item \textbf{Prediction Result Screen:} Tahmin sonuçları görüntüleme
    \item \textbf{History Detail Screen:} Tahmin detayları
    \item \textbf{Edit Profile Screen:} Profil düzenleme
\end{itemize}

\textbf{Kullanıcı Akış Diyagramı:}

\begin{verbatim}
[Splash Screen]
    ↓
[Token kontrolü] → Var ise → [Home Screen]
    ↓ Yok ise
[Login Screen] → [Register Screen] (opsiyonel)
    ↓
[Home Screen] ← [Bottom Navigation] → [Camera/History/Stats/Profile]
    ↓
[Camera Screen] → Fotoğraf çek/seç
    ↓
[Upload & Processing] → Loading indicator
    ↓
[Prediction Result Screen] → Kaydet
    ↓
[History Screen] ← Güncellendi
\end{verbatim}

\subsubsection{State Management - Provider Pattern}

Uygulama state yönetimi için Provider pattern kullanılmıştır. Provider, Flutter ekosisteminde önerilen ve yaygın olarak kullanılan bir state management çözümüdür.

\textbf{AuthProvider Örneği:}

\begin{verbatim}
class AuthProvider extends ChangeNotifier {
  AuthState _state = AuthState.initial;
  User? _currentUser;
  String? _accessToken;

  Future<void> login(String email, String password) async {
    _state = AuthState.loading;
    notifyListeners();

    try {
      final response = await _authService.login(email, password);
      _currentUser = response.user;
      _accessToken = response.accessToken;

      await _storageService.saveToken(response.accessToken);

      _state = AuthState.authenticated;
    } catch (e) {
      _state = AuthState.error;
    }
    notifyListeners();
  }

  void logout() {
    _currentUser = null;
    _accessToken = null;
    _storageService.clearToken();
    _state = AuthState.unauthenticated;
    notifyListeners();
  }
}
\end{verbatim}

\pagebreak{}

\subsubsection{API Entegrasyonu}

Backend API ile iletişim için Dio HTTP client kütüphanesi kullanılmıştır. Dio, interceptor desteği, timeout yönetimi ve error handling özellikleri sunmaktadır.

\textbf{API Service İmplementasyonu:}

\begin{verbatim}
class ApiService {
  final Dio _dio;
  static const String baseUrl = 'https://api.gastronomgoz.com';

  ApiService() : _dio = Dio(BaseOptions(
    baseUrl: baseUrl,
    connectTimeout: Duration(seconds: 10),
    receiveTimeout: Duration(seconds: 30),
    headers: {'Content-Type': 'application/json'},
  )) {
    _dio.interceptors.add(AuthInterceptor());
    _dio.interceptors.add(LoggingInterceptor());
  }

  Future<PredictionResult> predict({
    required File image,
    String? mealType,
    String? note,
  }) async {
    final formData = FormData.fromMap({
      'image': await MultipartFile.fromFile(
        image.path,
        filename: path.basename(image.path),
      ),
      if (mealType != null) 'meal_type': mealType,
      if (note != null) 'note': note,
    });

    final response = await _dio.post(
      '/api/predict',
      data: formData,
    );

    return PredictionResult.fromJson(response.data['data']);
  }
}
\end{verbatim}

\textbf{Auth Interceptor - Token Yönetimi:}

\begin{verbatim}
class AuthInterceptor extends Interceptor {
  @override
  void onRequest(
    RequestOptions options,
    RequestInterceptorHandler handler,
  ) async {
    final token = await StorageService.getAccessToken();
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }

  @override
  void onError(
    DioException err,
    ErrorInterceptorHandler handler,
  ) async {
    if (err.response?.statusCode == 401) {
      // Token expired, refresh token
      final refreshed = await _refreshToken();
      if (refreshed) {
        handler.resolve(await _retry(err.requestOptions));
        return;
      }
    }
    handler.next(err);
  }
}
\end{verbatim}

\pagebreak{}

\subsubsection{Kullanıcı Arayüzü Tasarımı}

Arayüz tasarımında Google Material Design 3.0 prensipleri uygulanmıştır \cite{google2023material}. Kullanılabilirlik (usability) için Nielsen'in 10 heuristiği \cite{nielsen1994usability} ve Norman'ın tasarım prensipleri \cite{norman2013design} dikkate alınmıştır.

\textbf{Renk Paleti:}
\begin{itemize}
    \item \textbf{Birincil renk:} Turuncu (\#FF6B35) - yemek ve enerji temalarını yansıtır
    \item \textbf{İkincil renk:} Yeşil (\#4CAF50) - sağlık ve doğallık hissi verir
    \item \textbf{Arkaplan:} Beyaz (\#FFFFFF) ve açık gri (\#F5F5F5)
    \item \textbf{Hata rengi:} Kırmızı (\#F44336)
    \item \textbf{Başarı rengi:} Yeşil (\#4CAF50)
\end{itemize}

\textbf{Tipografi:}
\begin{itemize}
    \item \textbf{Ana font:} Roboto (Android) / San Francisco (iOS)
    \item \textbf{Başlık boyutu:} 24sp (bold)
    \item \textbf{Alt başlık:} 18sp (medium)
    \item \textbf{Gövde metni:} 14sp (regular)
    \item \textbf{Küçük metin:} 12sp (light)
\end{itemize}

\subsubsection{Kamera Entegrasyonu}

Yemek fotoğrafı çekimi için Flutter'ın \texttt{camera} paketi kullanılmıştır. Paket, hem yerleşik kamera hem de galeri erişimi sağlamaktadır.

\textbf{Kamera Controller:}

\begin{verbatim}
class CameraController {
  CameraController? _controller;
  List<CameraDescription>? _cameras;

  Future<void> initialize() async {
    _cameras = await availableCameras();
    _controller = CameraController(
      _cameras![0],  // Arka kamera
      ResolutionPreset.high,
      enableAudio: false,
    );
    await _controller!.initialize();
  }

  Future<XFile> takePicture() async {
    if (!_controller!.value.isInitialized) {
      throw Exception('Kamera hazır değil');
    }
    return await _controller!.takePicture();
  }
}
\end{verbatim}

\subsubsection{Veri Görselleştirme}

İstatistik ekranında grafik gösterimi için \texttt{fl\_chart} paketi kullanılmıştır. Paket, line chart, bar chart ve pie chart gibi çeşitli grafik türlerini desteklemektedir.

\textbf{Grafik Türleri:}
\begin{itemize}
    \item \textbf{Line Chart:} 7 günlük kalori trend grafiği
    \item \textbf{Bar Chart:} Haftalık öğün dağılımı
    \item \textbf{Pie Chart:} Öğün türlerine göre kalori dağılımı
\end{itemize}

\pagebreak{}

\subsection{Önerilen Deployment ve Dağıtım Stratejisi}

\subsubsection{Backend Deployment Stratejisi}

Backend uygulama, cloud platform üzerinde production deployment için containerization yaklaşımı önerilmektedir.

\textbf{Not:} Bu bölümde sunulan deployment stratejisi, sistemin production ortamına geçişi için hazırlanmıştır. Mevcut durumda sistem development ortamında (SQLite, Flask development server) çalışmaktadır.

\textbf{Docker Container Yapılandırması:}

\begin{verbatim}
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["gunicorn", "--bind", "0.0.0.0:5000",
     "--workers", "4", "--timeout", "120", "app:app"]
\end{verbatim}

\textbf{Production Konfigürasyonu:}
\begin{itemize}
    \item \textbf{Web Server:} Gunicorn (4 worker process)
    \item \textbf{Reverse Proxy:} Nginx
    \item \textbf{Database:} PostgreSQL (managed service)
    \item \textbf{File Storage:} AWS S3 / Google Cloud Storage
    \item \textbf{SSL/TLS:} Let's Encrypt sertifikası
\end{itemize}

\subsubsection{Mobil Uygulama Dağıtımı}

\textbf{Android Platform:}
\begin{itemize}
    \item APK ve App Bundle (.aab) formatında build
    \item Google Play Console üzerinden dağıtım
    \item Minimum SDK: Android 5.0 (API Level 21)
    \item Target SDK: Android 13 (API Level 33)
\end{itemize}

\textbf{iOS Platform:}
\begin{itemize}
    \item App Store Connect üzerinden dağıtım
    \item Minimum iOS versiyonu: iOS 12.0
    \item Xcode build tools ve provisioning profile
\end{itemize}

\subsubsection{Continuous Integration / Continuous Deployment (CI/CD)}

Otomatik build ve deployment için GitHub Actions kullanılmıştır:

\begin{verbatim}
# .github/workflows/deploy.yml
name: Deploy Backend
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build Docker image
        run: docker build -t gastronomgoz-backend .
      - name: Push to registry
        run: docker push gastronomgoz-backend
      - name: Deploy to production
        run: ssh deploy@server 'docker-compose up -d'
\end{verbatim}

\pagebreak{}
