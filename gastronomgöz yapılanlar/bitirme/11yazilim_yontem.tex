\section{METODOLOJİ VE KULLANILAN TEKNOLOJİLER}

Bu bölümde, GastronomGöz sisteminin geliştirilmesinde kullanılan yöntemler, yazılım teknolojileri, donanım altyapısı, derin öğrenme mimarileri ve metodolojiler detaylı olarak açıklanmaktadır.

\subsection{Sistem Mimarisi}

GastronomGöz sistemi üç katmanlı mimari yapısında tasarlanmıştır \cite{fielding2002rest}. Sunum katmanında Flutter framework ile geliştirilmiş cross-platform mobil uygulama (iOS ve Android), iş mantığı katmanında Python Flask ile geliştirilmiş RESTful API servisleri ve veri katmanında ilişkisel veritabanı (SQLite/PostgreSQL) ile yapay zeka model dosyaları bulunmaktadır. Bu mimari katmanlar arası bağımlılığı azaltarak sistemin bakım ve genişletilebilirliğini artırmaktadır.

\subsection{Derin Öğrenme Modelleri}

Yemek görüntülerinin sınıflandırılması için ResNet50 mimarisi kullanılmıştır \cite{he2016resnet}. ResNet50, 50 katmanlı derin bir evrişimsel sinir ağı olup, artık bağlantılar sayesinde çok derin ağlarda ortaya çıkan gradyan kaybolması problemini çözmektedir. Artık bağlantılar, bir katmanın çıktısının sonraki katmanlara doğrudan aktarılmasını sağlayarak ağın daha verimli öğrenmesine olanak tanır. Model Food-101 veri kümesi üzerinde önceden eğitilmiş ağırlıklar kullanılarak transfer learning yöntemiyle uyarlanmıştır \cite{pan2010transfer}. Bu yaklaşım kaynak alan bilgisinin hedef alana aktarılmasını sağlayarak eğitim süresini kısaltmakta ve az veri ile yüksek başarım elde edilmesine olanak tanımaktadır \cite{yosinski2014transfer}.

Model yapılandırması 224×224×3 boyutunda RGB görüntü giriş katmanı, Food-101 ağırlıkları ile başlatılmış ResNet50 temel ağı, global average pooling katmanı, 256 nöronlu tam bağlı katman (ReLU aktivasyonu), aşırı uyumu önlemek için 0.5 oranında dropout katmanı ve N sınıf çıkışı için softmax aktivasyonlu çıkış katmanından oluşmaktadır. Sistemimizde 101 sınıf yemek tanıma için model eğitilmiştir.

Görüntü bölütleme işlemi için U2-Net modeli kullanılmıştır \cite{qin2020u2net}. U2-Net, geleneksel U-Net mimarisinin \cite{ronneberger2015unet} geliştirilmiş versiyonu olup, iç içe U-yapıları sayesinde çok ölçekli öznitelik çıkarımı gerçekleştirir. Model çıktısı piksel düzeyinde bir maske haritasıdır ve her piksel için [0,1] aralığında bir değer üretir. Eşik değeri 0.5 olarak belirlenmiş, bu değerin üzerindeki pikseller yemek nesnesi, altındakiler arkaplan olarak sınıflandırılmıştır. U2-Net hafif versiyonu (U2NET-P) 4.7 milyon parametre ile mobil platformlar için uygun hale getirilmiştir.

Tek görüntüden derinlik haritası elde etmek için MiDaS algoritması kullanılmıştır \cite{ranftl2020midas}. MiDaS, farklı veri kümelerinden öğrenilen bilgileri birleştirerek sağlam derinlik tahmini yapmaktadır. Derinlik bilgisi yemek porsiyon hacminin üç boyutlu olarak hesaplanmasında kullanılmaktadır. Algoritma görüntünün her pikseli için göreceli derinlik değeri üretir ve bu değerler normalize edilerek [0, 255] aralığına getirilir.

\subsection{Backend Geliştirme}

Backend API servisleri Python Flask framework kullanılarak geliştirilmiştir (versiyon 3.1.0) \cite{grinberg2018flask}. Flask micro-framework yapısı sayesinde hafif ve esnek bir geliştirme ortamı sunmaktadır. Sistemde Flask-SQLAlchemy ORM desteği \cite{sqlalchemy2023}, Flask-JWT-Extended ile JWT tabanlı kimlik doğrulama, Flask-Marshmallow ile veri serileştirme ve validasyon, Flask-CORS ile cross-origin resource sharing desteği ve Flask-Bcrypt ile şifre hashleme \cite{grassi2017bcrypt} kullanılmıştır.

Sistem REST mimari prensiplerine uygun olarak tasarlanmıştır \cite{fielding2002rest}. Tüm API endpoint'leri standart HTTP metodlarını (GET, POST, PUT, DELETE) kullanmakta ve JSON formatında veri alışverişi yapmaktadır. API endpoint'leri beş kategoride gruplandırılmıştır: kimlik doğrulama (kullanıcı kaydı, giriş, token yenileme), kullanıcı profili (profil bilgileri, hedef kalori ayarları), tahmin (yemek görüntüsü analizi ve kalori hesaplama), geçmiş (tahmin kayıtları ve günlük loglar) ve analitik (istatistiksel raporlama).

Kullanıcı kimlik doğrulaması JSON Web Token standardı kullanılarak gerçekleştirilmiştir \cite{jones2020jwt}. Sistem iki tür token kullanmaktadır: kısa ömürlü access token (15 dakika, API isteklerinde kullanılır) ve uzun ömürlü refresh token (30 gün, access token yenilemede kullanılır). Kullanıcı şifreleri Bcrypt algoritması ile hashlenmiş ve veritabanında düz metin olarak saklanmamıştır. Bcrypt, NIST tarafından önerilen bir şifreleme yöntemidir \cite{grassi2017bcrypt}.

\subsection{Mobil Uygulama Geliştirme}

\subsubsection{Flutter ve Dart}

Mobil uygulama, Google tarafından geliştirilen Flutter framework'ü (versiyon 3.16+) ve Dart programlama dili kullanılarak geliştirilmiştir \cite{wu2018flutter}. Flutter, tek kod tabanı (single codebase) ile hem iOS hem de Android platformlarında native performans sunan cross-platform bir framework'tür \cite{biorn2018dartlang}.

Mobil uygulamada http paketi ile RESTful API iletişimi, provider paketi ile durum yönetimi, shared\_preferences ile yerel veri saklama, image\_picker ile kamera ve galeri erişimi, fl\_chart ile grafik ve veri görselleştirme, intl paketi ile uluslararasılaştırma ve tarih formatlama işlevleri sağlanmıştır.

\subsubsection{Kullanıcı Arayüzü Tasarımı}

Arayüz tasarımında Google Material Design 3.0 prensipleri uygulanmıştır \cite{google2023material}. Kullanılabilirlik (usability) için Nielsen'in 10 heuristiği \cite{nielsen1994usability} ve Norman'ın tasarım prensipleri \cite{norman2013design} dikkate alınmıştır.

Renk paleti olarak yemek ve enerji temalarını yansıtan turuncu (\#FF6B35) birincil renk, sağlık ve doğallık hissi veren yeşil (\#4CAF50) ikincil renk, beyaz (\#FFFFFF) ve açık gri (\#F5F5F5) arkaplan renkleri kullanılmıştır.

\subsection{Veritabanı Tasarımı}

\subsubsection{İlişkisel Veritabanı Şeması}

Sistem, SQLite (geliştirme ortamı) ve PostgreSQL (production ortamı) veritabanlarını desteklemektedir \cite{hipp2020sqlite}. Veritabanı şeması, normalizasyon kurallarına (3NF - Third Normal Form) uygun olarak tasarlanmıştır \cite{karwin2010sql}.

Veritabanı şeması altı ana tablodan oluşmaktadır. Kullanıcı bilgileri users tablosunda (id, email, password\_hash, created\_at), fiziksel özellikler user\_profiles tablosunda (user\_id, height, weight, age, gender, activity\_level), hedef kalori ve besin değerleri user\_goals tablosunda saklanmaktadır. Yapay zeka tahmin kayıtları prediction\_history tablosunda (user\_id, image\_path, food\_class, weight\_g, calories), günlük kalori takibi daily\_logs tablosunda (user\_id, date, total\_calories, meal\_count), besin değerleri ise food\_database tablosunda (name, calories\_per\_100g, protein, carbs, fats) tutulmaktadır.

\subsubsection{ORM ve Veri Erişim Katmanı}

SQLAlchemy ORM kütüphanesi kullanılarak veritabanı işlemleri Python sınıfları üzerinden gerçekleştirilmiştir \cite{sqlalchemy2023}. Bu yaklaşım, SQL injection saldırılarını önlemekte ve kod bakımını kolaylaştırmaktadır.

\subsection{Görüntü İşleme Pipeline'ı}

Yemek görüntülerinin analizi çok aşamalı bir işlem hattı ile gerçekleştirilmektedir. İlk olarak görüntü yükleme ve doğrulama aşamasında JPEG/PNG formatı kontrolü ve maksimum 10 MB boyut kontrolü yapılmaktadır. Ardından ön işleme aşamasında görüntü 224×224 piksel boyutuna (ResNet50 giriş boyutu) getirilmekte ve piksel değerleri [0,1] aralığına normalize edilmektedir. Bu işlemler için OpenCV ve Pillow kütüphaneleri kullanılmıştır \cite{opencv2020, pillow2023}. Sonraki adımlarda sırasıyla ResNet50 modeli ile yemek sınıflandırması, U2-Net ile yemek nesnesinin maskesi elde edilmesi, MiDaS ile derinlik haritası çıkarımı, maske alanı ve derinlik bilgisi kullanılarak porsiyon ağırlığı hesaplama ve son olarak veritabanından kalori değerlerinin çekilmesi gerçekleştirilmektedir.

\subsection{Ağırlık Tahmin Metodolojisi}

Porsiyon ağırlığı tahmini iki aşamalı bir yaklaşımla gerçekleştirilmektedir. Her yemek sınıfı için üç standart porsiyon boyutu (küçük, orta, büyük) tanımlanmıştır. Referans ağırlıklar WHO besin veritabanı ve USDA standartlarına göre belirlenmiştir.

Segmentasyon maskesinden elde edilen piksel alanı kullanılarak ince ayar yapılmaktadır. Normalize edilmiş alan oranı $A_{norm} = A_{mask} / A_{total}$ olarak hesaplanır. Burada $A_{mask}$ maskedeki yemek nesnesi piksel sayısı, $A_{total}$ ise toplam görüntü piksel sayısıdır. Son ağırlık $W_{final} = W_{base} \times (1 + \alpha \cdot (A_{norm} - 0.5))$ formülü ile hesaplanır. Burada $W_{base}$ referans ağırlık, $\alpha$ ince ayar katsayısı (0.4) ve $W_{final}$ son tahmin edilen ağırlıktır.

\subsection{Model Eğitimi}

Model eğitimi sırasında aşırı uyumu önlemek için veri artırımı teknikleri uygulanmıştır \cite{shorten2019survey}. Albumentations kütüphanesi kullanılarak \cite{buslaev2020albumentations} rastgele döndürme (±15 derece), yatay çevirme, rastgele parlaklık ve kontrast ayarı (±20\%), rastgele renk doygunluğu değişimi ve rastgele kesme ile ölçekleme transformasyonları uygulanmıştır.

ResNet50 ince ayarı için Adam optimizer, 0.0001 başlangıç öğrenme oranı (cosine annealing scheduler ile), 32 batch boyutu, 200 epoch (early stopping ile), categorical cross-entropy kayıp fonksiyonu ve Top-1 ile Top-5 başarım metrikleri kullanılmıştır. Sistem PyTorch 2.3.1 \cite{paszke2019pytorch}, TensorFlow 2.16.1 \cite{abadi2016tensorflow} ve NumPy 1.24.0 \cite{harris2020numpy} kütüphaneleri ile geliştirilmiştir. Donanım olarak NVIDIA RTX 3060 (12 GB VRAM), Intel i7-11700K CPU ve 32 GB DDR4 RAM kullanılmıştır.

\subsection{Performans Optimizasyonu}

Sistem performansını artırmak için çeşitli optimizasyon teknikleri uygulanmıştır. Yapay zeka modelleri ilk kullanımda yüklenerek tekil nesne örüntüsü ile bellekte tutulmaktadır. İşlenmiş görüntüler geçici olarak önbelleklenmekte ve sık kullanılan API uç noktaları için önbellek mekanizması kullanılmaktadır. Uzun süren yapay zeka işlemleri için arka plan görev kuyruğu kullanılarak asenkron işleme sağlanmış, ayrıca sık sorgulanan veritabanı kolonlarına indeks eklenerek sorgu performansı artırılmıştır.

\subsection{Test ve Doğrulama}

Sistemin doğruluğu ve güvenilirliği için kapsamlı test süreçleri uygulanmıştır. Bireysel fonksiyonların pytest framework ile birim testleri yapılmış, API uç noktalarının bütünleşme testleri gerçekleştirilmiştir. Beta kullanıcılar ile gerçek senaryolarda kullanıcı kabul testleri yapılmış, ayrıca yük testi ve yanıt süresi analizleri ile başarım testleri yürütülmüştür.

\pagebreak{}
