\section{METODOLOJİ VE KULLANILAN TEKNOLOJİLER}

Bu bölümde, GastronomGöz sisteminin geliştirilmesinde kullanılan yöntemler, yazılım teknolojileri, donanım altyapısı, derin öğrenme mimarileri ve metodolojiler detaylı olarak açıklanmaktadır.

\subsection{Sistem Mimarisi}

GastronomGöz sistemi üç katmanlı mimari yapısında tasarlanmıştır \cite{fielding2002rest}. Sunum katmanında Flutter framework ile geliştirilmiş cross-platform mobil uygulama (iOS ve Android), iş mantığı katmanında Python Flask ile geliştirilmiş RESTful API servisleri ve veri katmanında ilişkisel veritabanı (SQLite/PostgreSQL) ile yapay zeka model dosyaları bulunmaktadır. Bu mimari katmanlar arası bağımlılığı azaltarak sistemin bakım ve genişletilebilirliğini artırmaktadır.

\subsection{Derin Öğrenme Modelleri}

Yemek görüntülerinin sınıflandırılması için ResNet50 mimarisi kullanılmıştır \cite{he2016resnet}. ResNet50, 50 katmanlı derin bir evrişimsel sinir ağı olup, artık bağlantılar sayesinde çok derin ağlarda ortaya çıkan gradyan kaybolması problemini çözmektedir. Artık bağlantılar, bir katmanın çıktısının sonraki katmanlara doğrudan aktarılmasını sağlayarak ağın daha verimli öğrenmesine olanak tanır. Model Food-101 veri kümesi üzerinde önceden eğitilmiş ağırlıklar kullanılarak transfer learning yöntemiyle uyarlanmıştır \cite{pan2010transfer}. Bu yaklaşım kaynak alan bilgisinin hedef alana aktarılmasını sağlayarak eğitim süresini kısaltmakta ve az veri ile yüksek başarım elde edilmesine olanak tanımaktadır \cite{yosinski2014transfer}.

Model yapılandırması 224×224×3 boyutunda RGB görüntü giriş katmanı, Food-101 ağırlıkları ile başlatılmış ResNet50 temel ağı, global average pooling katmanı, 256 nöronlu tam bağlı katman (ReLU aktivasyonu), aşırı uyumu önlemek için 0.5 oranında dropout katmanı ve N sınıf çıkışı için softmax aktivasyonlu çıkış katmanından oluşmaktadır. Sistemimizde 101 sınıf yemek tanıma için model eğitilmiştir.

Görüntü bölütleme işlemi için U²-Net modeli kullanılmıştır \cite{qin2020u2net}. U²-Net, geleneksel U-Net mimarisinin \cite{ronneberger2015unet} geliştirilmiş versiyonu olup, iç içe U-yapıları sayesinde çok ölçekli öznitelik çıkarımı gerçekleştirir. Model çıktısı piksel düzeyinde bir maske haritasıdır ve her piksel için [0,1] aralığında bir değer üretir. Eşik değeri 0.5 olarak belirlenmiş, bu değerin üzerindeki pikseller yemek nesnesi, altındakiler arkaplan olarak sınıflandırılmıştır. U²-Net hafif versiyonu (U2NETP) 4.7 milyon parametre ile mobil platformlar için uygun hale getirilmiştir.

Tek görüntüden derinlik haritası elde etmek için MiDaS algoritması entegre edilmiştir \cite{ranftl2020midas}. MiDaS, farklı veri kümelerinden öğrenilen bilgileri birleştirerek sağlam derinlik tahmini yapmaktadır. Derinlik bilgisi, bölütleme maskesi ile birlikte yemek porsiyon ağırlığı tahmininde destekleyici veri olarak kullanılmaktadır. Algoritma görüntünün her pikseli için göreceli derinlik değeri üretir ve bu değerler normalize edilerek [0, 255] aralığına getirilir.

\subsection{Backend Geliştirme}

Backend API servisleri Python Flask framework kullanılarak geliştirilmiştir (versiyon 3.1.0) \cite{grinberg2018flask}. Flask micro-framework yapısı sayesinde hafif ve esnek bir geliştirme ortamı sunmaktadır. Sistemde Flask-SQLAlchemy ORM desteği \cite{sqlalchemy2023}, Flask-JWT-Extended ile JWT tabanlı kimlik doğrulama, Flask-Marshmallow ile veri serileştirme ve validasyon, Flask-CORS ile cross-origin resource sharing desteği ve Flask-Bcrypt ile şifre hashleme \cite{grassi2017bcrypt} kullanılmıştır.

Sistem REST mimari prensiplerine uygun olarak tasarlanmıştır \cite{fielding2002rest}. Tüm API endpoint'leri standart HTTP metodlarını (GET, POST, PUT, DELETE) kullanmakta ve JSON formatında veri alışverişi yapmaktadır. API endpoint'leri beş kategoride gruplandırılmıştır: kimlik doğrulama (kullanıcı kaydı, giriş, token yenileme), kullanıcı profili (profil bilgileri, hedef kalori ayarları), tahmin (yemek görüntüsü analizi ve kalori hesaplama), geçmiş (tahmin kayıtları ve günlük loglar) ve analitik (istatistiksel raporlama).

Kullanıcı kimlik doğrulaması JSON Web Token standardı kullanılarak gerçekleştirilmiştir \cite{jones2020jwt}. Sistem iki tür token kullanmaktadır: kısa ömürlü access token (15 dakika, API isteklerinde kullanılır) ve uzun ömürlü refresh token (30 gün, access token yenilemede kullanılır). Kullanıcı şifreleri Bcrypt algoritması ile hashlenmiş ve veritabanında düz metin olarak saklanmamıştır. Bcrypt, NIST tarafından önerilen bir şifreleme yöntemidir \cite{grassi2017bcrypt}.

\subsection{Mobil Uygulama Geliştirme}

\subsubsection{Flutter ve Dart}

Mobil uygulama, Google tarafından geliştirilen Flutter framework'ü (versiyon 3.16+) ve Dart programlama dili kullanılarak geliştirilmiştir \cite{wu2018flutter}. Flutter, tek kod tabanı (single codebase) ile hem iOS hem de Android platformlarında native performans sunan cross-platform bir framework'tür \cite{biorn2018dartlang}.

Mobil uygulamada http paketi ile RESTful API iletişimi, provider paketi ile durum yönetimi, shared\_preferences ile yerel veri saklama, image\_picker ile kamera ve galeri erişimi, fl\_chart ile grafik ve veri görselleştirme, intl paketi ile uluslararasılaştırma ve tarih formatlama işlevleri sağlanmıştır.

\subsubsection{Kullanıcı Arayüzü Tasarımı}

Arayüz tasarımında Google Material Design 3.0 prensipleri uygulanmıştır \cite{google2023material}. Kullanılabilirlik (usability) için Nielsen'in 10 heuristiği \cite{nielsen1994usability} ve Norman'ın tasarım prensipleri \cite{norman2013design} dikkate alınmıştır.

Renk paleti olarak birincil renk lila, ikincil renk olarak beyaz ve açık gri arkaplan renkleri kullanılmıştır.

\subsection{Veritabanı Tasarımı}

\subsubsection{İlişkisel Veritabanı Şeması}

Sistem, geliştirme ortamında SQLite kullanır; production ortamında \texttt{DATABASE\_URL} tanımlıysa (ör. PostgreSQL) bu veritabanına bağlanır, tanımlı değilse SQLite’a geri düşer \cite{hipp2020sqlite}. Şema, 3NF prensiplerine uygun olacak şekilde tasarlanmıştır \cite{karwin2010sql}.

\begin{itemize}
  \item \textbf{users}: Kullanıcı kimlik ve temel hesap bilgileri (id, email, password\_hash, name, is\_active, created\_at, updated\_at).
  \item \textbf{user\_profiles}: Kullanıcının fiziksel/dil/tercih bilgileri (user\_id – unique, height, weight, age, gender, activity\_level, daily\_calorie\_goal, goal\_type, unit\_system, language, notifications\_enabled, created\_at, updated\_at). TDEE/BMI hesapları buradaki alanlardan türetilir.
  \item \textbf{prediction\_history}: Yapay zeka tahmin kayıtları (user\_id, image\_path, mask\_path, food\_class, confidence, estimated\_grams, calories, protein, carbs, fat, user\_note, meal\_type, is\_favorite, model\_version, processing\_time, depth\_info, segmentation\_info, created\_at, updated\_at). Görsel yollar ve besin makroları burada tutulur; weight alanı \texttt{estimated\_grams} olarak geçer.
  \item \textbf{daily\_logs}: Günlük kalori ve öğün özetleri (user\_id, date, total\_calories, total\_meals, breakfast\_calories, lunch\_calories, dinner\_calories, snack\_calories, daily\_goal, goal\_achieved, created\_at, updated\_at). Öğün sayısı \texttt{total\_meals} ile izlenir.
\end{itemize}

\subsubsection{ORM ve Veri Erişim Katmanı}

SQLAlchemy ORM kütüphanesi kullanılarak veritabanı işlemleri Python sınıfları üzerinden gerçekleştirilmiştir \cite{sqlalchemy2023}. Bu yaklaşım, SQL injection saldırılarını önlemekte ve kod bakımını kolaylaştırmaktadır.

\subsection{Görüntü İşleme Pipeline'ı}

Yemek görüntülerinin analizi çok aşamalı bir işlem hattı ile gerçekleştirilmektedir. İlk olarak görüntü yükleme ve doğrulama aşamasında JPEG/PNG formatı kontrolü ve maksimum 10 MB boyut kontrolü yapılmaktadır. Ardından ön işleme aşamasında görüntü 224×224 piksel boyutuna (ResNet50 giriş boyutu) getirilmekte ve piksel değerleri [0,1] aralığına normalize edilmektedir. Bu işlemler için OpenCV ve Pillow kütüphaneleri kullanılmıştır \cite{opencv2020, pillow2023}. Sonraki adımlarda sırasıyla ResNet50 modeli ile yemek sınıflandırması, U2-Net ile yemek nesnesinin maskesi elde edilmesi, MiDaS ile derinlik haritası çıkarımı, maske alanı ve derinlik bilgisi kullanılarak porsiyon ağırlığı hesaplama ve son olarak veritabanından kalori değerlerinin çekilmesi gerçekleştirilmektedir.

\subsection{Ağırlık Tahmin Metodolojisi}

Porsiyon ağırlığı tahmini iki aşamalı bir yaklaşımla gerçekleştirilmektedir. Her yemek sınıfı için üç standart porsiyon boyutu (küçük, orta, büyük) tanımlanmıştır. Referans ağırlıklar WHO besin veritabanı ve USDA standartlarına göre belirlenmiştir.

Segmentasyon maskesinden elde edilen piksel alanı kullanılarak ince ayar yapılmaktadır. Normalize edilmiş alan oranı $A_{norm} = A_{mask} / A_{total}$ olarak hesaplanır. Burada $A_{mask}$ maskedeki yemek nesnesi piksel sayısı, $A_{total}$ ise toplam görüntü piksel sayısıdır. Son ağırlık $W_{final} = W_{base} \times (1 + \alpha \cdot (A_{norm} - 0.5))$ formülü ile hesaplanır. Burada $W_{base}$ referans ağırlık, $\alpha$ ince ayar katsayısı (0.4) ve $W_{final}$ son tahmin edilen ağırlıktır.

\subsection{Model Eğitimi}

Model eğitimi sırasında aşırı uyumu önlemek için veri artırımı teknikleri uygulanmıştır \cite{shorten2019survey}. Albumentations kütüphanesi kullanılarak \cite{buslaev2020albumentations} rastgele döndürme (±15 derece), yatay çevirme, rastgele parlaklık ve kontrast ayarı (±20\%), rastgele renk doygunluğu değişimi ve rastgele kesme ile ölçekleme transformasyonları uygulanmıştır.

ResNet50 ince ayarı için Adam optimizer, 0.0001 başlangıç öğrenme oranı (cosine annealing scheduler ile), 32 batch boyutu, 200 epoch (early stopping ile), categorical cross-entropy kayıp fonksiyonu ve Top-1 ile Top-5 başarım metrikleri kullanılmıştır. Sistem PyTorch 2.3.1 \cite{paszke2019pytorch}, TensorFlow 2.16.1 \cite{abadi2016tensorflow} ve NumPy 1.24.0 \cite{harris2020numpy} kütüphaneleri ile geliştirilmiştir. Model eğitimi NVIDIA RTX 3060 (12 GB VRAM) GPU ile gerçekleştirilmiş, sistem geliştirmesi ve testleri MacBook Air M2 (8-core CPU, 10-core GPU, 16 GB Unified Memory) üzerinde yürütülmüştür.

\subsection{Performans Optimizasyonu}

Sistemde, yapay zeka modelleri tekil (singleton) ve lazy-loading deseniyle ilk kullanımda yüklenip bellekte tutulur; böylece sonraki isteklerde yeniden yükleme yapılmaz. Model ve kalori verisi (calories\_per\_101class\_100g.csv) belleğe alınarak tekrar kullanılır. Bunun dışında:

\begin{itemize}
  \item API yanıtları veya işlenmiş görüntüler için bir önbellek katmanı (Redis vb.) uygulanmamıştır.
  \item Uzun süren yapay zeka işlemleri için bir arka plan görev kuyruğu (Celery/RQ) bulunmamaktadır; istekler senkron çalışır.
  \item Sık sorgulanan kolonlarda seçili indeksler vardır (örn. user\_id, created\_at, meal\_type), ancak ek bir genel indeksleme veya cache stratejisi tanımlı değildir.
\end{itemize}

Özetle mevcut optimizasyon, model ve veri setinin ilk yüklemeden sonra bellekte tutulmasıyla sınırlıdır; API önbellekleme ya da asenkron görev kuyruğu henüz devreye alınmamıştır.

\subsection{Test ve Doğrulama}

Sistemin doğruluğu ve güvenilirliği için kapsamlı test süreçleri uygulanmıştır. Bireysel fonksiyonların pytest framework ile birim testleri yapılmış, API uç noktalarının bütünleşme testleri gerçekleştirilmiştir. Beta kullanıcılar ile gerçek senaryolarda kullanıcı kabul testleri yapılmış, ayrıca yük testi ve yanıt süresi analizleri ile başarım testleri yürütülmüştür.

